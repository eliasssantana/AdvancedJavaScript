// TRABALHANDO COM SPREAD OPARATOR
const str = "Digital Innovation One"
const arr = [1,2,3,4];
const arr2 = arr.concat(5,6,7);//   UTILIZANDO O MÉTODO CONCAT DO ARRAY PARA UNIR DOIS ARRAYS EM UM SÓ.

const arr3 = [...arr, 1,4,6,7,8] // UTILIZANDO O SPREAD OPERATO PARA FAZER A MESMA COISA QUE O CONCAT. POR QUE NÃO UTILIZAR APENAS O NOME DO ARRAY?! É ELEMENTAR MEU CARO, VEJA SÓ: UTILIZAR O NOME DO ARRAY APENAS IRÁ ADICIONAR TODOS O ARRAY CHAMADO 'ARR' PARA A PRIMEIRA POSIÇÃO DO MEU NOVO ARRAY; CONTUDO, SE UTILIZO OS '...' EU IREI 'COPIAR' CADA ELEMENTO DO ARRAY ORIGINAL. OU SEJA, UTILIZANDO O SPREAD OPERATOR, ESTOU COPIANDO CADA ELEMENTO DE UM ARRAY, NÃO O ARRAY EM SI.
// UTILIZANDO APENAS O NOME DO ARRAY E NADA MAIS PARA UNIR ARRAYS


const arr4 = [arr, 3,6,8,9,9,0];


// O SPREAD ELE MEIO QUE CLONA OS ELEMENTOS DO ARRAY ORIGINAL E MANTÉM O CONCEITO DA IMUTABILIDADE
const arr5 = [...arr3,...arr,...arr4]; // POSSO UNIR QUANTOS ARRAYS EU DESEJAR.

// FAZEM A MESMAS COISA, COM A DIFERENÇA QUE NO PRIMEIRO EU CLONO OS ELEMENTOS INDIVIDUALMENTE, UTILIZANDO O SPREAD PARA ISSO. jÁ NO SEGUNDO CASO É UM POUCO DIFERENTE, EU COPIO TODO ARRAY E ATRIBUO A VARIÁVEL 'ARRCLONE'.
const arrClonado = [...arr];
const arrClone = arr;
const arrClonado2 = {...arr}; // AQUI EU CRIEI UM OBJETO ONDE CADA ELEMENTO DO ARRAY ORIGINAL RECEBE UM ÍNDICE EXPLÍCITO COMO CHAVE.

// console.log(arr2);
// console.log(arr4);
// console.log(arr5);
console.log(arrClonado);
console.log(arrClone);
console.log(arrClonado2)


function logArgs(a,b,c,...args){
    console.log(a,b,c);
    console.log(args, arguments);
    console.log(typeof args) // COMO ARRAY É UM OBJETO, O RESULTADO ,COMO SE ESPERAR. É... UM OBJETO.
}

// logArgs(...str) // PASSO UM ARRAY DO TIPO STRING COM ARGUMENTO, POIS UTILIZANDO OS '...' ISSO SIGNIFICA UM SPREAD, OU SEJA, É BASICAMENTE UM CÓPIA DE UM ARRAY. COMO SABEMOS STRING É UMA CADEIA DE CARACTERES, OU SEJA, UM ARRAY.


// logArgs(arr);// AQUI O 'ARR' SERÁ INTERPRETADO COMO UM ÚNICO ARGUMENTO PARA A FUNÇÃO; TODO O RESTO NÃO SERÁ DEFINIDO. POR ISSO O OUTPUT SERÁ UNDEFINED PARA OS OUTROS ARGUMENTOS.

// console.log(...arr, arr);

// PASSANDO UM SPREAD OPERATOR COMO CHAVE E VALOR PARA UM OBJETO LITERAL

const firstObj = {
    chave: 12345
}

const secondObj = {
    ...firstObj,
    chave2: "valor" // A ORDEM IMPORTA. CHAVE CHAMADO 'CHAVE' JÁ EXISTE E ESTOU SOBRESCREVENDO SEU VALOR. POR ISSO, AO INVÉS DE REPETIR NOME DE CHAVES , O JAVASCRIPT IRÁ EXIBIR SOMENTE UMA CHAVE COM NOMES IGUAIS E IRÁ SOBRESCREVE O ANTERIOR.
}
const thirdObjMarged = {
    ...secondObj
}
// console.log(firstObj);
console.log(secondObj);
console.log(thirdObjMarged);

// const arrFromObj = [...firstObj]; // DARÁ ERRO, PORQUE UM OBJETO LITERAL NÃO É ITERÁVEL, E SPREAD OPERATOR SÓ É APLICÁVEL À OBJETOS ITERÁVEIS.
// object is not iterable (cannot read property Symbol(Symbol.iterator))

const objTeste1 = {
    teste: 134
}
const objTeste2 = objTeste1;

objTeste2.teste = 17823;

console.log(objTeste1); // IRÁ EXIBIR A PROPRIEDADE TESTE COM VALOR ALTERADO POIS EU NÃO CRIE UMA CÓPIA, AMBOS OBJETOS APONTAM PARA A PROPRIEDADE ORIGINAL DO OBJETO 'OBJTESTE1'. PARA SE CRIAR UM CLONE É INTERESSANTE UTILIZAR O SPREAD OPERATOR PARA ISSO.
const obj = {
    chave: "valor",
    subObject: {
        chave: "valor" // APESAR DE DEFINIR O VALOR DE CHAVE PARA 'VALOR' VOCÊ VERÁ QUE SERÁ ALTERADO POR UM CLONE DE 'OBJ', POIS O SPREAD FAZ UM CÓPIA RASA- OU SHALLOW CLONE. SUBPROPRIEDADES TÊM SEU VALOR ALTERADO POR UM CLONE.
    }
}

const obj2 = {...obj, subObject: {...obj.subObject}}; // UTILIZO O SPREAD OPERATOR PARA CRIAR UM CLONE DO MEU OBJETO ORIGINAL. E O 'OBJ2' FAZ UM CLONE DO SUBOBJETO VALOR DA PROPRIEDADE 'SUBOBJECT'.

obj2.chave = "value";
obj2.subObject.chave = "value";

console.log(obj); // VALOR DA PROPRIEDADE 'CHAVE' NO OBJETO 'OBJ' NÃO FOI ALTERADO, PORÉM O 'OBJ2' TEVE O VALOR DA SUA PROPRIEDADE 'CHAVE' ALTERADO.
console.log(obj2);
console.log(obj);